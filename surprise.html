<!-- <!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Magic Holiday - Pine & Helix</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Noto+Sans+SC:wght@700&display=swap" rel="stylesheet">
    <style>
        /* === æ ·å¼åŒºåŸŸ === */
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; transition: background 1s ease; }
        
        /* é‡‡ç”¨æå…‰æ·±é’èƒŒæ™¯ï¼Œæœ€è¡¬æ‰˜ç™½è‰²å’Œé’è‰²ç²’å­ */
        body.bg-aurora { background: radial-gradient(circle at top, #0f2027 0%, #203a43 50%, #2c5364 100%); }

        #main-title {
            position: absolute; top: 20px; left: 0; width: 100%;
            text-align: center; z-index: 50; pointer-events: none; opacity: 0; transition: all 0.5s ease;
            font-family: 'Great Vibes', cursive;
            background: linear-gradient(to bottom, #ffffff, #aaddff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(173, 216, 230, 0.5);
            font-size: 5rem; white-space: nowrap;
        }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 200; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #fff;
        }
        #btn-start {
            padding: 15px 50px; font-size: 20px; background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            border: none; border-radius: 30px; color: #fff; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.5); margin-top: 30px; transition: transform 0.2s;
        }
        #btn-start:hover { transform: scale(1.05); }

        /* 2D å¼¹çª—æ ·å¼ */
        #photo-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.5);
            max-width: 80%; max-height: 80%; background: #fff; padding: 10px 10px 40px 10px;
            box-shadow: 0 30px 60px rgba(0,0,0,0.8); z-index: 150;
            opacity: 0; pointer-events: none; transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            border-radius: 4px;
        }
        #photo-modal.active { opacity: 1; transform: translate(-50%, -50%) scale(1) rotate(-3deg); }
        #photo-modal img { max-width: 100%; max-height: 60vh; display: block; }
        #photo-caption { text-align: center; color: #333; font-family: 'Great Vibes', cursive; font-size: 2rem; margin-top: 5px; }

        #input_video {
            position: absolute; bottom: 20px; left: 20px;
            width: 150px; height: 112px; border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.2);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transform: scaleX(-1); z-index: 90; object-fit: cover;
            transition: opacity 0.5s ease;
            opacity: 0.5;
        }
        #input_video:hover { opacity: 1; }

        ::-webkit-scrollbar { display: none; }
        
        @media (max-width: 768px) {
            #main-title { font-size: 3.5rem; top: 15px; }
            #start-screen h1 { font-size: 3rem !important; }
            #input_video { width: 100px; height: 75px; bottom: 10px; left: 10px; }
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body class="bg-aurora">

    <div id="main-title">Merry Christmas</div>

    <div id="start-screen">
        <h1 style="font-family: 'Great Vibes'; font-size: 4rem; color: #aaddff; margin: 0;">Pine & Helix</h1>
        <div style="margin-top:20px; text-align:center; color:#aaa; font-size:16px; line-height:1.8;">
            ğŸ–ï¸ <strong>å•æ‰‹äº¤äº’ (Left Hand)</strong><br>
            ğŸ¤Ÿ åä¸‰æŒ‡ä¼¸å±• â” çˆ†ç‚¸ç‰¹æ•ˆ<br>
            ğŸ‘Œ æ‹‡æŒ‡é£ŸæŒ‡æåˆ â” å±•ç¤ºç…§ç‰‡<br>
            ğŸ‘† é£ŸæŒ‡/æ‰‹æŒç§»åŠ¨ â” æ—‹è½¬æ ‘ä½“
        </div>
        <button id="btn-start">Enter Magic âœ¨</button>
    </div>

    <div id="photo-modal">
        <img id="modal-img" src="" alt="Memory">
        <div id="photo-caption">Sweet Memory</div>
    </div>

    <video id="input_video" playsinline webkit-playsinline></video>

    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size; attribute vec3 customColor; attribute vec3 spherePos; attribute float type;     
        varying vec3 vColor; varying float vType; varying vec3 vPos;
        uniform float uTime; uniform float uExplosion; uniform float uBeat;      
        void main() {
            vColor = customColor; vType = type;
            float t = uExplosion;
            float ease = 1.0 - pow(1.0 - t, 3.0);
            vec3 finalPos = mix(position, spherePos, ease);
            vPos = finalPos;
            
            float beatScale = 1.0;
            if (t < 0.2) beatScale += uBeat * 0.1 * (1.0 - t*3.0); 
            
            vec4 mvPosition = modelViewMatrix * vec4(finalPos * beatScale, 1.0);
            
            // ç²’å­å¤§å°æ§åˆ¶
            float s = size;
            // èºæ—‹ç²’å­(type 3)å¯¹èŠ‚æ‹æ›´æ•æ„Ÿ
            if(type > 2.5) s *= (1.0 + uBeat * 0.3);
            else if(type > 0.5) s *= (1.0 + uBeat * 0.2);
            
            gl_PointSize = s * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform float uTime; uniform float uBeat; uniform float uExplosion;
        varying vec3 vColor; varying float vType; varying vec3 vPos;
        void main() {
            vec2 center = vec2(0.5, 0.5);
            float dist = distance(gl_PointCoord, center);
            if(dist > 0.5) discard;
            
            float glow = 1.0 - (dist * 2.0);
            glow = pow(glow, 1.5); // æŸ”å’Œå…‰æ™•
            
            vec3 finalColor = vColor;
            
            if(uExplosion > 0.1) {
                vec3 rainbow = 0.5 + 0.5 * cos(uTime * 2.0 + vPos.xyx * 0.05 + vec3(0, 2, 4));
                finalColor = mix(finalColor, rainbow, uExplosion * 0.8);
            }
            
            float alpha = 1.0;
            
            // èºæ—‹ç²’å­(type 3)çš„ç‰¹æ•ˆ
            if(vType > 2.5) {
                // æµå…‰é—ªçƒ
                float flash = 0.5 + 0.5 * sin(uTime * 3.0 - vPos.y * 0.1);
                finalColor += vec3(0.3) * flash;
                // èŠ‚æ‹å¢å¼º
                finalColor += finalColor * uBeat * 0.6;
            } else if (vType > 1.5) {
                // æ™®é€šè£…é¥°çƒé—ªçƒ
                float flash = 0.5 + 0.5 * sin(uTime * 5.0 + vType * 10.0);
                finalColor += vec3(0.5) * flash * uBeat * 2.0;
            }
            
            alpha = 0.9 * glow;
            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

    <script>
        // === ğŸ› ï¸ æœ¬åœ°èµ„æºé…ç½®åŒº ===
        const localPhotoList = [
            'photos/1.jpg', 'photos/2.jpg', 'photos/3.jpg', 'photos/4.jpg', 'photos/5.jpg', 'photos/6.jpg', 'photos/7.jpg', 'photos/8.jpg', 'photos/9.jpg', 'photos/10.jpg', 'photos/11.jpg', 'photos/12.jpg', 'photos/13.jpg'
        ];
        const localMusicPath = 'music/bgm.mp3';
        // ==========================

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        const state = { 
            explosion: 0.0, targetExplosion: 0.0, photoActive: false, 
            enableGestureRot: true, enableRotX: true, enableRotY: true, 
            lastHandPos: { x: null, y: null }, rotVelocity: { x: 0, y: 0 }, 
            
            treeHeight: 80, 
            rotationSpeed: 0.002,
            inertia: 0.95,
            gestureSensitivity: 3.0,
            explosionDecay: 0.06,
            particleCount: isMobile ? 18000 : 35000, // å¢åŠ ç²’å­æ•°ä»¥æ”¯æŒæ¾æ ‘+å®½èºæ—‹
            cameraZ: 110,
        };

        let scene, camera, renderer, clock;
        let particleSystem, treeGroup, topDecoration;
        let loadedImages = [];
        let audioCtx, analyser, dataArray, audioEl;
        
        document.getElementById('btn-start').addEventListener('click', () => {
            const screen = document.getElementById('start-screen');
            screen.style.opacity = 0; setTimeout(() => screen.remove(), 1000);
            document.getElementById('main-title').style.opacity = 1;
            loadLocalPhotos(); initAudio(); initThree(); startHandTracking();
        });

        function loadLocalPhotos() {
            localPhotoList.forEach(path => {
                const img = new Image(); img.src = path;
                img.onload = () => loadedImages.push(img);
            });
        }

        // æ‰¾åˆ°åŸæœ‰çš„ initAudio å‡½æ•°ï¼Œæ›¿æ¢ä¸ºä»¥ä¸‹å†…å®¹ï¼š

        function initAudio() {
                // åˆ›å»º AudioContext
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!audioCtx) {
                    audioCtx = new AudioContext();
                }

                // å¦‚æœ audioEl è¿˜æ²¡åˆ›å»ºï¼Œåˆ™åˆ›å»º
                if (!audioEl) {
                    audioEl = new Audio();
                    audioEl.loop = true;
                    audioEl.src = localMusicPath; 
                    // âš ï¸ é‡è¦ä¿®å¤ï¼šåˆ é™¤äº† crossOrigin = "anonymous"ï¼Œè¿™åœ¨æœ¬åœ°è°ƒè¯•æ—¶ç»å¸¸å¯¼è‡´éŸ³é¢‘æ— æ³•æ’­æ”¾
                }

                // åˆ›å»ºåˆ†æå™¨
                if (!analyser) {
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 256;
                    dataArray = new Uint8Array(analyser.frequencyBinCount);
                    
                    // å°è¯•åˆ›å»ºæºå¹¶è¿æ¥
                    // æ³¨æ„ï¼šæŸäº›æµè§ˆå™¨å¦‚æœåœ¨æ²¡æœ‰CORSå¤´çš„æƒ…å†µä¸‹è¿æ¥MediaElementSourceå¯èƒ½ä¼šæŠ¥é”™
                    // å¦‚æœè¿™é‡ŒæŠ¥é”™ï¼ŒéŸ³é¢‘èƒ½æ’­æ”¾ä½†æ²¡æœ‰å¯è§†åŒ–æ•ˆæœã€‚ä¸ºä¿è¯å£°éŸ³ï¼ŒåŠ  try-catch
                    try {
                        const source = audioCtx.createMediaElementSource(audioEl);
                        source.connect(analyser);
                        analyser.connect(audioCtx.destination);
                    } catch (e) {
                        console.warn("MediaElementSource è¿æ¥å¤±è´¥ (å¯èƒ½æ˜¯è·¨åŸŸé—®é¢˜)ï¼ŒéŸ³é¢‘å°†æ’­æ”¾ä½†æ— èŠ‚æ‹æ•ˆæœ:", e);
                        // å¦‚æœè¿æ¥å¤±è´¥ï¼Œç›´æ¥è®©éŸ³é¢‘æ’­æ”¾ï¼Œä¸ç»è¿‡åˆ†æå™¨ï¼Œä¿è¯æœ‰å£°éŸ³
                        // è¿™ç§æƒ…å†µä¸‹ç›´æ¥ä¸åšèŠ‚ç‚¹è¿æ¥ï¼Œç”± audioEl è‡ªå·±è¾“å‡º
                    }
                }

                // æ ¸å¿ƒä¿®å¤ï¼šç¡®ä¿ AudioContext å·²æ¿€æ´»ï¼Œå¹¶å¤„ç†æ’­æ”¾ Promise
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }

                const playPromise = audioEl.play();

                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log("éŸ³é¢‘æ’­æ”¾æˆåŠŸï¼");
                    }).catch(error => {
                        console.error("éŸ³é¢‘æ’­æ”¾å¤±è´¥:", error);
                        // å†æ¬¡å°è¯•ï¼šæ·»åŠ ä¸€ä¸ªä¸€æ¬¡æ€§çš„å…¨å±€ç‚¹å‡»äº‹ä»¶æ¥è§¦å‘æ’­æ”¾
                        document.addEventListener('click', function resumePlay() {
                            if (audioCtx.state === 'suspended') audioCtx.resume();
                            audioEl.play();
                            document.removeEventListener('click', resumePlay);
                        }, { once: true });
                    });
                }
            }

        function initThree() {
            clock = new THREE.Clock(); scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x0f2027, 0.003);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, state.cameraZ); camera.lookAt(0, 35, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(10, 20, 30); scene.add(dirLight);
            treeGroup = new THREE.Group(); scene.add(treeGroup);
            
            createParticles(); createTopObject(); createSnow();
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // === ğŸŒ² + ğŸ§¬ æ ¸å¿ƒç”Ÿæˆï¼šæ¾æ ‘åŸºåº• + å¤§é¢—ç²’åŒèºæ—‹ ===
        function createParticles() {
            if(particleSystem) { treeGroup.remove(particleSystem); particleSystem.geometry.dispose(); particleSystem.material.dispose(); }
            
            const count = state.particleCount;
            const geo = new THREE.BufferGeometry();
            const positions = [], spherePos = [], colors = [], sizes = [], types = [];
            const h = state.treeHeight; 

            // é¢œè‰²å®šä¹‰
            const colorGreen = new THREE.Color(0x228b22);
            const colorDarkGreen = new THREE.Color(0x006400);
            const colorTrunk = new THREE.Color(0x5c4033);
            
            // èºæ—‹é…è‰² (å‚è€ƒå›¾ç‰‡)
            const colorWhite = new THREE.Color(0xffffff);
            const colorCyan = new THREE.Color(0x00ffff);
            const colorGold = new THREE.Color(0xffd700);

            // 1. ç”Ÿæˆæ ‘å¹²
            const trunkCount = Math.floor(count * 0.08);
            for(let i=0; i<trunkCount; i++) {
                const t = i / trunkCount; const y = t * h - 10; const r = (1 - t) * 2.0 + 0.5; const a = Math.random() * Math.PI * 2;
                positions.push(Math.cos(a)*r, y, Math.sin(a)*r);
                addCommonAttribs(positions[positions.length-3], positions[positions.length-2], positions[positions.length-1]);
                colors.push(colorTrunk.r, colorTrunk.g, colorTrunk.b); sizes.push(2.0); types.push(0);
            }

            // 2. ç”ŸæˆåŒèºæ—‹å…‰å¸¦ (å ç”¨çº¦ 25% ç²’å­)
            const helixCount = Math.floor(count * 0.25);
            const helixRotations = 6.0;
            const helixWidth = 3.5; // å…‰å¸¦å®½åº¦ï¼Œè¶Šå®½è¶Šåƒä¸å¸¦

            for(let i=0; i<helixCount; i++) {
                const t = i / helixCount;
                const y = t * h - 10;
                
                // èºæ—‹åŠå¾„ (éœ€ç•¥å¤§äºæ¾æ ‘æ ‘æçš„åŠå¾„)
                // æ¾æ ‘æœ€å¤§åŠå¾„çº¦ä¸º h * 0.5, è¿™é‡Œè®¾ä¸º h * 0.55 ä¿è¯åŒ…è£¹
                const rBase = (1 - t) * (h * 0.55) + 3;
                
                // åŒèºæ—‹ç›¸ä½
                const strand = (i % 2 === 0) ? 0 : 1;
                const angleOffset = strand * Math.PI; 
                const angle = t * Math.PI * 2 * helixRotations + angleOffset;
                
                // å¢åŠ éšæœºåç§»å½¢æˆå®½å¸¦
                const spreadX = (Math.random() - 0.5) * helixWidth;
                const spreadY = (Math.random() - 0.5) * helixWidth * 0.5;
                const spreadZ = (Math.random() - 0.5) * helixWidth;

                const x = Math.cos(angle) * rBase + spreadX;
                const z = Math.sin(angle) * rBase + spreadZ;
                const finalY = y + spreadY;

                positions.push(x, finalY, z);
                addCommonAttribs(x, finalY, z);
                
                // èºæ—‹é¢œè‰²åˆ†å¸ƒ (ç™½ä¸ºä¸»ï¼Œé’/é‡‘ç‚¹ç¼€)
                const rnd = Math.random();
                let c, s;
                if(rnd > 0.9) { c = colorGold; s = 5.5; } // é‡‘è‰²å¤§é¢—ç²’
                else if(rnd > 0.65) { c = colorCyan; s = 4.5; } // é’è‰²ä¸­é¢—ç²’
                else { c = colorWhite; s = 4.0; } // ç™½è‰²åŸºç¡€é¢—ç²’
                
                colors.push(c.r, c.g, c.b);
                sizes.push(s); // è®¾ç½®è¾ƒå¤§çš„å°ºå¯¸
                types.push(3); // Type 3: èºæ—‹ç‰¹æ•ˆ
            }

            // 3. ç”Ÿæˆæ¾æ ‘æå¶ (å‰©ä½™ç²’å­)
            const leafCount = count - trunkCount - helixCount;
            const layers = 22; 
            for(let i=0; i<leafCount; i++) {
                const layerId = Math.floor(Math.random() * layers); 
                const layerProgress = layerId / layers; 
                const layerY = layerProgress * h - 10; 
                const maxBranchLen = (1 - layerProgress) * (h * 0.45); // æ ‘æåŠå¾„æ¯”èºæ—‹å°
                
                const angle = Math.random() * Math.PI * 2; 
                const dist = Math.random() * maxBranchLen; 
                const gravity = (dist / maxBranchLen) * 8; 
                const y = layerY - gravity + (Math.random()-0.5)*2;
                
                const x = Math.cos(angle) * dist; 
                const z = Math.sin(angle) * dist;

                positions.push(x, y, z);
                addCommonAttribs(x, y, z);

                // æ ‘å¶é¢œè‰²éšæœºæ·±æµ…
                const mix = Math.random();
                const col = colorGreen.clone().lerp(colorDarkGreen, mix * 0.5);
                colors.push(col.r, col.g, col.b);
                sizes.push(1.5); // æ¾é’ˆä¿æŒç»†å°
                types.push(1);
            }

            function addCommonAttribs(x, y, z) {
                const v = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize(); 
                v.multiplyScalar(40 + Math.random()*50); 
                spherePos.push(v.x, v.y + 20, v.z);
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('spherePos', new THREE.Float32BufferAttribute(spherePos, 3));
            geo.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute('type', new THREE.Float32BufferAttribute(types, 1));
            
            state.uniforms = { uTime: { value: 0 }, uExplosion: { value: 0 }, uBeat: { value: 0 } };
            const mat = new THREE.ShaderMaterial({ 
                uniforms: state.uniforms, 
                vertexShader: document.getElementById('vertexshader').textContent, 
                fragmentShader: document.getElementById('fragmentshader').textContent, 
                blending: THREE.AdditiveBlending, depthTest: false, transparent: true 
            });
            particleSystem = new THREE.Points(geo, mat); treeGroup.add(particleSystem);
        }

        // é¡¶é¥°ï¼šå‘å…‰çš„äº”è§’æ˜Ÿ
        function createTopObject() {
            if(topDecoration) treeGroup.remove(topDecoration);
            
            const shape = new THREE.Shape();
            const points = 5;
            for(let i=0; i<points*2; i++){
                const l = (i%2===0) ? 4 : 2; 
                const a = i / points * Math.PI;
                shape.lineTo(Math.cos(a)*l, Math.sin(a)*l);
            }
            const geom = new THREE.ExtrudeGeometry(shape, {depth: 1, bevelEnabled: true, bevelThickness: 0.5, bevelSize: 0.5, bevelSegments: 2});
            const mat = new THREE.MeshBasicMaterial({color: 0xffdd00}); // äº®é‡‘
            
            topDecoration = new THREE.Mesh(geom, mat);
            topDecoration.position.y = state.treeHeight + 2;
            topDecoration.rotation.z = Math.PI;
            
            // åŠ ä¸€ä¸ªå‘å…‰çš„å¤–å£³
            const glowGeom = new THREE.ExtrudeGeometry(shape, {depth: 1.2, bevelEnabled: true, bevelThickness: 0.6, bevelSize: 0.6});
            const glowMat = new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.3});
            const glowMesh = new THREE.Mesh(glowGeom, glowMat);
            topDecoration.add(glowMesh);
            
            treeGroup.add(topDecoration);
        }

        function createSnow() {
            const g=new THREE.BufferGeometry(); const pos=[]; for(let i=0;i<1000;i++) pos.push((Math.random()-0.5)*200,Math.random()*150,(Math.random()-0.5)*200);
            g.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));
            window.snowSystem=new THREE.Points(g,new THREE.PointsMaterial({color:0xffffff,size:0.6,transparent:true,opacity:0.5}));
            scene.add(window.snowSystem);
        }

        function animate() {
            requestAnimationFrame(animate); const t = clock.getElapsedTime();
            let beat = 0; if(analyser) { analyser.getByteFrequencyData(dataArray); let sum = 0; for(let i=0; i<15; i++) sum+=dataArray[i]; beat = (sum/15/255) * 1.0; }
            if(state.uniforms) { 
                state.uniforms.uTime.value = t; state.uniforms.uBeat.value = beat; 
                state.explosion += (state.targetExplosion - state.explosion) * state.explosionDecay; 
                state.uniforms.uExplosion.value = state.explosion; 
            }
            
            treeGroup.rotation.y += state.rotVelocity.y; treeGroup.rotation.x += state.rotVelocity.x;
            state.rotVelocity.x *= state.inertia; state.rotVelocity.y *= state.inertia;
            
            if (Math.abs(state.rotVelocity.y) < 0.001) {
                treeGroup.rotation.y += state.rotationSpeed + state.explosion * 0.01; 
                treeGroup.rotation.x *= 0.95; 
            }

            if(topDecoration) {
                topDecoration.rotation.y -= 0.02; 
                const s = 1 + beat * 0.3; topDecoration.scale.set(s,s,s);
            }

            if(window.snowSystem) {
                const pos = window.snowSystem.geometry.attributes.position.array;
                for(let i=0; i<pos.length; i+=3) {
                    pos[i+1] -= 0.3; pos[i] += Math.sin(t * 0.5 + pos[i+1] * 0.05) * 0.1;
                    if(pos[i+1] < -20) { pos[i+1] = 100; pos[i] = (Math.random()-0.5)*200; }
                }
                window.snowSystem.geometry.attributes.position.needsUpdate = true;
            }
            renderer.render(scene, camera);
        }

        function startHandTracking() {
            const video = document.getElementById('input_video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            
            hands.onResults(results => {
                if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                    state.lastHandPos = { x: null, y: null }; state.targetExplosion = 0; return; 
                }
                const lm = results.multiHandLandmarks[0]; 
                const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                if (pinchDist < 0.05) { 
                    if (!state.photoActive) { showRandomPhoto(); state.photoActive = true; }
                } else if (pinchDist > 0.08 && state.photoActive) { 
                    document.getElementById('photo-modal').classList.remove('active'); state.photoActive = false; 
                }
                const handSize = Math.hypot(lm[0].x - lm[9].x, lm[0].y - lm[9].y);
                const tips = [12, 16, 20]; let totalTipDist = 0;
                tips.forEach(idx => { totalTipDist += Math.hypot(lm[0].x - lm[idx].x, lm[0].y - lm[idx].y); });
                const avgRatio = (totalTipDist / 3) / handSize;
                state.targetExplosion = Math.min(Math.max((avgRatio - 1.3) * 1.5, 0), 1);
                
                if (state.enableGestureRot) {
                    const handCenter = lm[9]; 
                    if (state.lastHandPos.x !== null) {
                        const deltaX = handCenter.x - state.lastHandPos.x;
                        const deltaY = handCenter.y - state.lastHandPos.y;
                        if (Math.abs(deltaX) > 0.002 || Math.abs(deltaY) > 0.002) {
                            if (state.enableRotY) state.rotVelocity.y = -deltaX * state.gestureSensitivity; 
                            if (state.enableRotX) state.rotVelocity.x = deltaY * state.gestureSensitivity; 
                        }
                    }
                    state.lastHandPos = { x: handCenter.x, y: handCenter.y };
                }
            });
            const cameraUtils = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 320, height: 240 });
            cameraUtils.start();
        }

        function showRandomPhoto() { 
            if(loadedImages.length === 0) return; 
            const img = loadedImages[Math.floor(Math.random() * loadedImages.length)]; 
            const modal = document.getElementById('photo-modal'); 
            document.getElementById('modal-img').src = img.src; 
            modal.classList.add('active'); 
        }
    </script>
</body>
</html> -->

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Magic Holiday - To my Zhuzhu</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Noto+Sans+SC:wght@700&display=swap" rel="stylesheet">
    <style>
        /* === æ ·å¼åŒºåŸŸ === */
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; transition: background 1s ease; }
        
        /* é‡‡ç”¨æå…‰æ·±é’èƒŒæ™¯ */
        body.bg-aurora { background: radial-gradient(circle at top, #0f2027 0%, #203a43 50%, #2c5364 100%); }

        #main-title {
            position: absolute; top: 20px; left: 0; width: 100%;
            text-align: center; z-index: 50; pointer-events: none; opacity: 0; transition: all 0.5s ease;
            font-family: 'Great Vibes', cursive;
            background: linear-gradient(to bottom, #ffffff, #aaddff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(173, 216, 230, 0.5);
            font-size: 5rem; white-space: nowrap;
        }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 200; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #fff;
        }
        #btn-start {
            padding: 15px 50px; font-size: 20px; background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            border: none; border-radius: 30px; color: #fff; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.5); margin-top: 30px; transition: transform 0.2s;
        }
        #btn-start:hover { transform: scale(1.05); }

        /* 2D å¼¹çª—æ ·å¼ (ä¿ç•™æåˆçœ‹å¤§å›¾åŠŸèƒ½) */
        #photo-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.5);
            max-width: 80%; max-height: 80%; background: #fff; padding: 10px 10px 40px 10px;
            box-shadow: 0 30px 60px rgba(0,0,0,0.8); z-index: 150;
            opacity: 0; pointer-events: none; transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            border-radius: 4px;
        }
        #photo-modal.active { opacity: 1; transform: translate(-50%, -50%) scale(1) rotate(-3deg); }
        #photo-modal img { max-width: 100%; max-height: 60vh; display: block; }
        #photo-caption { text-align: center; color: #333; font-family: 'Great Vibes', cursive; font-size: 2rem; margin-top: 5px; }

        #input_video {
            position: absolute; bottom: 20px; left: 20px;
            width: 150px; height: 112px; border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.2);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transform: scaleX(-1); z-index: 90; object-fit: cover;
            transition: opacity 0.5s ease;
            opacity: 0.5;
        }
        #input_video:hover { opacity: 1; }

        ::-webkit-scrollbar { display: none; }
        
        @media (max-width: 768px) {
            #main-title { font-size: 3.5rem; top: 15px; }
            #start-screen h1 { font-size: 3rem !important; }
            #input_video { width: 100px; height: 75px; bottom: 10px; left: 10px; }
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body class="bg-aurora">

    <div id="main-title">Merry Christmas Raminta! </div>

    <div id="start-screen">
        <h1 style="font-family: 'Great Vibes'; font-size: 4rem; color: #aaddff; margin: 0;">Pine & Helix</h1>
        <div style="margin-top:20px; text-align:center; color:#aaa; font-size:16px; line-height:1.8;">
            ğŸ–ï¸ <strong>Interaction Guide</strong><br>
            ğŸ¤ŸExtend palm â” Explosion effect<br>
            ğŸ‘ŒPinch your fingers â” View larger image<br>
            ğŸ‘†Move your palm â” Rotate the tree
        </div>
        <button id="btn-start">Start Magic âœ¨</button>
    </div>

    <div id="photo-modal">
        <img id="modal-img" src="" alt="Memory">
        <div id="photo-caption">Sweet Memory</div>
    </div>

    <video id="input_video" playsinline webkit-playsinline></video>

    <!-- ç²’å­ç€è‰²å™¨ -->
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size; attribute vec3 customColor; attribute vec3 spherePos; attribute float type;     
        varying vec3 vColor; varying float vType; varying vec3 vPos;
        uniform float uTime; uniform float uExplosion; uniform float uBeat;      
        void main() {
            vColor = customColor; vType = type;
            float t = uExplosion;
            float ease = 1.0 - pow(1.0 - t, 3.0);
            vec3 finalPos = mix(position, spherePos, ease);
            vPos = finalPos;
            
            float beatScale = 1.0;
            if (t < 0.2) beatScale += uBeat * 0.1 * (1.0 - t*3.0); 
            
            vec4 mvPosition = modelViewMatrix * vec4(finalPos * beatScale, 1.0);
            
            float s = size;
            if(type > 2.5) s *= (1.0 + uBeat * 0.3);
            else if(type > 0.5) s *= (1.0 + uBeat * 0.2);
            
            gl_PointSize = s * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform float uTime; uniform float uBeat; uniform float uExplosion;
        varying vec3 vColor; varying float vType; varying vec3 vPos;
        void main() {
            vec2 center = vec2(0.5, 0.5);
            float dist = distance(gl_PointCoord, center);
            if(dist > 0.5) discard;
            
            float glow = 1.0 - (dist * 2.0);
            glow = pow(glow, 1.5);
            
            vec3 finalColor = vColor;
            
            if(uExplosion > 0.1) {
                vec3 rainbow = 0.5 + 0.5 * cos(uTime * 2.0 + vPos.xyx * 0.05 + vec3(0, 2, 4));
                finalColor = mix(finalColor, rainbow, uExplosion * 0.8);
            }
            
            if(vType > 2.5) {
                float flash = 0.5 + 0.5 * sin(uTime * 3.0 - vPos.y * 0.1);
                finalColor += vec3(0.3) * flash;
                finalColor += finalColor * uBeat * 0.6;
            } else if (vType > 1.5) {
                float flash = 0.5 + 0.5 * sin(uTime * 5.0 + vType * 10.0);
                finalColor += vec3(0.5) * flash * uBeat * 2.0;
            }
            
            gl_FragColor = vec4(finalColor, 0.9 * glow);
        }
    </script>

    <script>
        // === ğŸ› ï¸ èµ„æºé…ç½® ===
        // è¯·ç¡®ä¿ photos æ–‡ä»¶å¤¹ä¸‹æœ‰å¯¹åº”çš„ jpg æ–‡ä»¶ï¼Œmusic æ–‡ä»¶å¤¹ä¸‹æœ‰ bgm.mp3
        const localPhotoList = [
            'photos/1.jpg', 'photos/2.jpg', 'photos/3.jpg', 'photos/4.jpg', 
            'photos/5.jpg', 'photos/6.jpg', 'photos/7.jpg', 'photos/8.jpg', 
            'photos/9.jpg', 'photos/10.jpg', 'photos/11.jpg', 'photos/12.jpg', 'photos/13.jpg'
        ];
        const localMusicPath = 'music/bgm.mp3';
        // ==========================

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        const state = { 
            explosion: 0.0, targetExplosion: 0.0, photoActive: false, 
            enableGestureRot: true, enableRotX: true, enableRotY: true, 
            lastHandPos: { x: null, y: null }, rotVelocity: { x: 0, y: 0 }, 
            
            treeHeight: 80, 
            rotationSpeed: 0.002,
            inertia: 0.95,
            gestureSensitivity: 3.0,
            explosionDecay: 0.06,
            particleCount: isMobile ? 18000 : 35000,
            cameraZ: 110,
        };

        let scene, camera, renderer, clock;
        let particleSystem, treeGroup, topDecoration;
        let loadedImages = []; // ç”¨äº2Då¼¹çª—å±•ç¤º
        let hangingPhotos = []; // ç”¨äºå­˜å‚¨3Dæ ‘ä¸Šçš„ç…§ç‰‡å¯¹è±¡ä»¥ä¾¿åŠ¨ç”»
        let audioCtx, analyser, dataArray, audioEl;
        
        // å¯åŠ¨æŒ‰é’®é€»è¾‘
        document.getElementById('btn-start').addEventListener('click', () => {
            const screen = document.getElementById('start-screen');
            // åˆå§‹åŒ–éŸ³é¢‘ï¼ˆåŒ…å«æœ¬åœ°æ–‡ä»¶å…¼å®¹ä¿®å¤ï¼‰
            initAudio();
            
            // ç•Œé¢è¿‡æ¸¡
            screen.style.opacity = 0; 
            setTimeout(() => screen.remove(), 1000);
            document.getElementById('main-title').style.opacity = 1;
            
            // åŠ è½½èµ„æºä¸ç¯å¢ƒ
            initThree(); 
            loadLocalPhotos(); // ç°åœ¨è¿™ä¸ªå‡½æ•°ä¼šæŠŠç…§ç‰‡æŒ‚åˆ°æ ‘ä¸Š
            startHandTracking();
        });

        // === ğŸ–¼ï¸ å›¾ç‰‡åŠ è½½ä¸æŒ‚è½½é€»è¾‘ (æ ¸å¿ƒä¿®æ”¹) ===
        function loadLocalPhotos() {
            const loader = new THREE.TextureLoader();
            // è§£å†³è·¨åŸŸçº¹ç†é—®é¢˜
            loader.setCrossOrigin('anonymous');

            localPhotoList.forEach((path, index) => {
                // 1. åŠ è½½ä¸º 2D Image å¯¹è±¡ (ä¾›æåˆå¼¹çª—ä½¿ç”¨)
                const img = new Image();
                img.src = path;
                loadedImages.push(img);

                // 2. åŠ è½½ä¸º 3D Texture (æŒ‚åœ¨æ ‘ä¸Š)
                loader.load(path, (texture) => {
                    addPhotoToTree(texture, index, localPhotoList.length);
                });
            });
        }

        // åˆ›å»º3Dç…§ç‰‡å¹¶æŒ‚è½½åˆ°æ ‘ä¸Š
        function addPhotoToTree(texture, index, total) {
            const aspect = texture.image.width / texture.image.height;
            const photoW = 6; 
            const photoH = photoW / aspect;

            // ç…§ç‰‡æœ¬ä½“
            const pGeo = new THREE.PlaneGeometry(photoW, photoH);
            const pMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const pMesh = new THREE.Mesh(pGeo, pMat);
            pMesh.position.z = 0.1; // ç•¥å¾®æµ®èµ·

            // ç™½è‰²è¾¹æ¡† (æ‹ç«‹å¾—é£æ ¼)
            const fW = photoW + 0.8; 
            const fH = photoH + 2.0;
            const fGeo = new THREE.PlaneGeometry(fW, fH);
            const fMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const fMesh = new THREE.Mesh(fGeo, fMat);
            fMesh.position.y = -0.5; // è®©ç…§ç‰‡åœ¨ç›¸æ¡†ä¸­åä¸Š

            // ç»„åˆ
            const group = new THREE.Group();
            group.add(fMesh);
            group.add(pMesh);

            // è®¡ç®—èºæ—‹ä½ç½®
            const h = state.treeHeight;
            // å‚ç›´åˆ†å¸ƒï¼šä»ä¸‹åˆ°ä¸Š (10% ~ 85%)
            const t = 0.1 + (index / total) * 0.75; 
            const y = t * h - 10;
            
            // åŠå¾„ï¼šéšé«˜åº¦æ”¶ç¼© (åœ†é”¥ä½“)
            const r = (1 - t) * 35 + 8; // åŸºåº•åŠå¾„35ï¼Œé¡¶éƒ¨åŠå¾„8
            
            // è§’åº¦ï¼šé»„é‡‘è§’èºæ—‹ï¼Œé¿å…é‡å 
            const angle = index * 2.4; 

            group.position.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
            
            // æœå‘ï¼šå…ˆé¢å‘ä¸­å¿ƒï¼Œå†æ—‹è½¬180åº¦é¢å‘å¤–ï¼Œå†åŠ ä¸€ç‚¹éšæœºæ‰°åŠ¨
            group.lookAt(0, y, 0);
            group.rotateY(Math.PI);
            group.rotateZ((Math.random()-0.5) * 0.4); // éšæœºæ­ªä¸€ç‚¹
            group.rotateX((Math.random()-0.5) * 0.2);

            // å­˜å…¥æ•°ç»„ä»¥ä¾¿åŠ¨ç”»æ‘†åŠ¨
            hangingPhotos.push({ mesh: group, offset: Math.random() * 100 });

            treeGroup.add(group);
        }

        // === ğŸµ éŸ³é¢‘é€»è¾‘ (åŒ…å«æœ¬åœ°æ–‡ä»¶ä¿®å¤) ===
        function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!audioCtx) audioCtx = new AudioContext();
            
            if (!audioEl) {
                audioEl = new Audio();
                audioEl.loop = true;
                audioEl.src = localMusicPath;
            }

            const isLocal = window.location.protocol === 'file:';
            
            if (isLocal) {
                console.warn("æœ¬åœ°æ–‡ä»¶æ¨¡å¼è¿è¡Œï¼šéŸ³é¢‘åˆ†æå·²ç¦ç”¨ä»¥é¿å…è·¨åŸŸé”™è¯¯ï¼Œå¯ç”¨æ¨¡æ‹ŸèŠ‚æ‹ã€‚");
                audioEl.play().catch(e => console.error(e));
                if (audioCtx.state === 'suspended') audioCtx.resume();
                analyser = null; // æ ‡è®°ä¸ºç©ºï¼Œè§¦å‘æ¨¡æ‹ŸèŠ‚æ‹
            } else {
                if (!analyser) {
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 256;
                    dataArray = new Uint8Array(analyser.frequencyBinCount);
                    try {
                        const source = audioCtx.createMediaElementSource(audioEl);
                        source.connect(analyser);
                        analyser.connect(audioCtx.destination);
                    } catch(e) { console.warn(e); }
                }
                if (audioCtx.state === 'suspended') audioCtx.resume();
                audioEl.play().catch(e => {
                    document.addEventListener('click', function r(){
                        if(audioCtx.state === 'suspended') audioCtx.resume();
                        audioEl.play(); document.removeEventListener('click', r);
                    }, {once:true});
                });
            }
        }

        function initThree() {
            clock = new THREE.Clock(); scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x0f2027, 0.003);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, state.cameraZ); camera.lookAt(0, 35, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(10, 20, 30); scene.add(dirLight);
            treeGroup = new THREE.Group(); scene.add(treeGroup);
            
            createParticles(); createTopObject(); createSnow();
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function createParticles() {
            if(particleSystem) { treeGroup.remove(particleSystem); particleSystem.geometry.dispose(); }
            const count = state.particleCount;
            const geo = new THREE.BufferGeometry();
            const positions = [], spherePos = [], colors = [], sizes = [], types = [];
            const h = state.treeHeight; 

            const colorGreen = new THREE.Color(0x228b22);
            const colorDarkGreen = new THREE.Color(0x006400);
            const colorTrunk = new THREE.Color(0x5c4033);
            const colorWhite = new THREE.Color(0xffffff);
            const colorCyan = new THREE.Color(0x00ffff);
            const colorGold = new THREE.Color(0xffd700);

            // æ ‘å¹²
            const trunkCount = Math.floor(count * 0.08);
            for(let i=0; i<trunkCount; i++) {
                const t = i / trunkCount; const y = t * h - 10; const r = (1 - t) * 2.0 + 0.5; const a = Math.random() * Math.PI * 2;
                positions.push(Math.cos(a)*r, y, Math.sin(a)*r);
                addAttr(positions, spherePos);
                colors.push(colorTrunk.r, colorTrunk.g, colorTrunk.b); sizes.push(2.0); types.push(0);
            }

            // åŒèºæ—‹
            const helixCount = Math.floor(count * 0.25);
            for(let i=0; i<helixCount; i++) {
                const t = i / helixCount; const y = t * h - 10;
                const rBase = (1 - t) * (h * 0.55) + 3;
                const strand = (i % 2 === 0) ? 0 : 1;
                const angle = t * Math.PI * 12 + strand * Math.PI; 
                const sx = (Math.random()-0.5)*3.5; const sy = (Math.random()-0.5)*1.5; const sz = (Math.random()-0.5)*3.5;
                const x = Math.cos(angle) * rBase + sx; const z = Math.sin(angle) * rBase + sz;
                positions.push(x, y + sy, z); addAttr(positions, spherePos);
                
                const rnd = Math.random();
                let c = colorWhite, s = 4.0;
                if(rnd > 0.9) { c = colorGold; s = 5.5; } else if(rnd > 0.65) { c = colorCyan; s = 4.5; }
                colors.push(c.r, c.g, c.b); sizes.push(s); types.push(3);
            }

            // æ ‘å¶
            const leafCount = count - trunkCount - helixCount;
            for(let i=0; i<leafCount; i++) {
                const layer = Math.floor(Math.random() * 22); 
                const lp = layer / 22; const ly = lp * h - 10; 
                const maxR = (1 - lp) * (h * 0.45);
                const angle = Math.random() * Math.PI * 2; const dist = Math.random() * maxR; 
                const gy = ly - (dist/maxR)*8 + (Math.random()-0.5)*2;
                positions.push(Math.cos(angle)*dist, gy, Math.sin(angle)*dist);
                addAttr(positions, spherePos);
                const col = colorGreen.clone().lerp(colorDarkGreen, Math.random()*0.5);
                colors.push(col.r, col.g, col.b); sizes.push(1.5); types.push(1);
            }

            function addAttr(posArr, sphereArr) {
                const l = posArr.length;
                const v = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(40+Math.random()*50);
                sphereArr.push(v.x, v.y+20, v.z);
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('spherePos', new THREE.Float32BufferAttribute(spherePos, 3));
            geo.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute('type', new THREE.Float32BufferAttribute(types, 1));
            
            state.uniforms = { uTime: { value: 0 }, uExplosion: { value: 0 }, uBeat: { value: 0 } };
            const mat = new THREE.ShaderMaterial({ 
                uniforms: state.uniforms, 
                vertexShader: document.getElementById('vertexshader').textContent, 
                fragmentShader: document.getElementById('fragmentshader').textContent, 
                blending: THREE.AdditiveBlending, depthTest: false, transparent: true 
            });
            particleSystem = new THREE.Points(geo, mat); treeGroup.add(particleSystem);
        }

        function createTopObject() {
            const shape = new THREE.Shape(); const pts = 5;
            for(let i=0; i<pts*2; i++){ const l = (i%2===0)?4:2; const a = i/pts*Math.PI; shape.lineTo(Math.cos(a)*l, Math.sin(a)*l); }
            const geom = new THREE.ExtrudeGeometry(shape, {depth:1, bevelEnabled:true, bevelThickness:0.5, bevelSize:0.5, bevelSegments:2});
            topDecoration = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({color:0xffdd00}));
            topDecoration.position.y = state.treeHeight + 2; topDecoration.rotation.z = Math.PI;
            const glow = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.3}));
            glow.scale.set(1.2,1.2,1.2); topDecoration.add(glow); treeGroup.add(topDecoration);
        }

        function createSnow() {
            const g=new THREE.BufferGeometry(); const pos=[]; for(let i=0;i<1000;i++) pos.push((Math.random()-0.5)*200,Math.random()*150,(Math.random()-0.5)*200);
            g.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));
            window.snowSystem=new THREE.Points(g,new THREE.PointsMaterial({color:0xffffff,size:0.6,transparent:true,opacity:0.5}));
            scene.add(window.snowSystem);
        }

        function animate() {
            requestAnimationFrame(animate); const t = clock.getElapsedTime();
            
            // èŠ‚æ‹å¤„ç†ï¼ˆå…¼å®¹æ— åˆ†æå™¨æƒ…å†µï¼‰
            let beat = 0;
            if(analyser) { 
                analyser.getByteFrequencyData(dataArray); 
                let sum = 0; for(let i=0; i<15; i++) sum+=dataArray[i]; 
                beat = (sum/15/255) * 1.0; 
            } else {
                beat = (Math.sin(t * 8) * 0.5 + 0.5) * 0.3; // æ¨¡æ‹Ÿå¿ƒè·³
            }

            if(state.uniforms) { 
                state.uniforms.uTime.value = t; state.uniforms.uBeat.value = beat; 
                state.explosion += (state.targetExplosion - state.explosion) * state.explosionDecay; 
                state.uniforms.uExplosion.value = state.explosion; 
            }
            
            // æ ‘æ•´ä½“æ—‹è½¬
            treeGroup.rotation.y += state.rotVelocity.y; treeGroup.rotation.x += state.rotVelocity.x;
            state.rotVelocity.x *= state.inertia; state.rotVelocity.y *= state.inertia;
            if (Math.abs(state.rotVelocity.y) < 0.001) {
                treeGroup.rotation.y += state.rotationSpeed + state.explosion * 0.01; 
                treeGroup.rotation.x *= 0.95; 
            }

            // é¡¶æ˜ŸåŠ¨ç”»
            if(topDecoration) { topDecoration.rotation.y -= 0.02; const s = 1 + beat * 0.3; topDecoration.scale.set(s,s,s); }
            
            // ç…§ç‰‡æ‘†åŠ¨åŠ¨ç”» (æ–°å¢)
            hangingPhotos.forEach(item => {
                // åƒé£é“ƒä¸€æ ·ç»• Z è½´å¾®å¾®æ‘†åŠ¨
                item.mesh.rotation.z += Math.sin(t * 2 + item.offset) * 0.003; 
            });

            // é›ªèŠ±åŠ¨ç”»
            if(window.snowSystem) {
                const pos = window.snowSystem.geometry.attributes.position.array;
                for(let i=0; i<pos.length; i+=3) {
                    pos[i+1] -= 0.3; pos[i] += Math.sin(t * 0.5 + pos[i+1] * 0.05) * 0.1;
                    if(pos[i+1] < -20) { pos[i+1] = 100; pos[i] = (Math.random()-0.5)*200; }
                }
                window.snowSystem.geometry.attributes.position.needsUpdate = true;
            }
            renderer.render(scene, camera);
        }

        function startHandTracking() {
            const video = document.getElementById('input_video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            
            hands.onResults(results => {
                if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                    state.lastHandPos = { x: null, y: null }; state.targetExplosion = 0; return; 
                }
                const lm = results.multiHandLandmarks[0]; 
                
                // æåˆæ‰‹åŠ¿æ£€æµ‹ (ç”¨äº2Då¼¹çª—å±•ç¤º)
                const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                if (pinchDist < 0.05) { 
                    if (!state.photoActive) { showRandomPhoto(); state.photoActive = true; }
                } else if (pinchDist > 0.08 && state.photoActive) { 
                    document.getElementById('photo-modal').classList.remove('active'); state.photoActive = false; 
                }
                
                // çˆ†ç‚¸æ‰‹åŠ¿æ£€æµ‹
                const handSize = Math.hypot(lm[0].x - lm[9].x, lm[0].y - lm[9].y);
                const tips = [12, 16, 20]; let totalTipDist = 0;
                tips.forEach(idx => { totalTipDist += Math.hypot(lm[0].x - lm[idx].x, lm[0].y - lm[idx].y); });
                const avgRatio = (totalTipDist / 3) / handSize;
                state.targetExplosion = Math.min(Math.max((avgRatio - 1.3) * 1.5, 0), 1);
                
                // æ—‹è½¬æ‰‹åŠ¿æ£€æµ‹
                if (state.enableGestureRot) {
                    const handCenter = lm[9]; 
                    if (state.lastHandPos.x !== null) {
                        const deltaX = handCenter.x - state.lastHandPos.x;
                        const deltaY = handCenter.y - state.lastHandPos.y;
                        if (Math.abs(deltaX) > 0.002 || Math.abs(deltaY) > 0.002) {
                            if (state.enableRotY) state.rotVelocity.y = -deltaX * state.gestureSensitivity; 
                            if (state.enableRotX) state.rotVelocity.x = deltaY * state.gestureSensitivity; 
                        }
                    }
                    state.lastHandPos = { x: handCenter.x, y: handCenter.y };
                }
            });
            const cameraUtils = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 320, height: 240 });
            cameraUtils.start();
        }

        function showRandomPhoto() { 
            if(loadedImages.length === 0) return; 
            const img = loadedImages[Math.floor(Math.random() * loadedImages.length)]; 
            const modal = document.getElementById('photo-modal'); 
            document.getElementById('modal-img').src = img.src; 
            modal.classList.add('active'); 
        }
    </script>
</body>
</html>